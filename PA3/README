user: zhanghw
user: xyshen

README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% make submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.y, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------
In the parser, the rules include program, class/class_list, 
feature/feature_list, formal/formal_list, expression/let_expression/term_
expression/case_branch/cases/init_expression and expressions. The expressions 
include block_expressions and actual_expressions.

Feature includes attribute feature and method feature. As a LR parser, those 
two types are differed by whether '(' formal_list ')' exists. In addition, 
formal and attribute feature is differentiated by whether there is ';' 
following. 

Feature_lists and formal_lists are both recursive rules, using left recursion, 
which is favored in Bison.

In expression rules, init_expr (initialization, used either in feature or let 
initialization) is identified by the initial ASSIGN operator. In both 
attribute feature and let expression, initialization is optional, so init_expr 
could also be empty. When it is empty, SET_NODELOC(0) and no_expr() is called.

Block_expr (block expressions) which is used in blocks, and actual_exprs used 
in dispatch expressions are recursively built. They are identified by ':' and 
','

Besides these rules, expressions (expr) could be identified by expression with 
ambiguity and without ambiguity. Expression with pure keywords, ID, constant 
is unambiguous. Expression with special keywords at the beginning or ending is 
also unambiguous, e.g. if...fi, while ... loop ... pool. Those expressions are parsed
with term_expr rules. On the other hand, expressions are ambiguous if special 
keywords are not at the beginning or ending of an expression. However, the 
ambiguity is solved by using precedence rules. The precedence and association 
are set according to Cool Syntax. 

Because we want to extend Let expression to the far end, we use precedence 
associated with production for let expression. The precedence is the lowest. 
For multiple binding in the LET expression, rules are recursive.

For error handling, we handle error in class definition, features, and 
expressions in block '{ expr; }'. In order to restart after error happens, 
some terminals need to be matched. For example, if class definition is wrong, 
it could recover from '{ feature_list};'. For wrong feature, it could recover 
from ';'. In block expressions, it could recover after this block finishes.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Tests:
In good.cl, we test
1.	Single and multiple features, attribute features with/without 
initialization, single formals and multiple formals

2.	Let expression with multiple binding, with/without initiation, nested let 
expression, and precedence between LET and other expressions

3.	Dispatch expressions test. Test three forms of dispatch expressions. Test 
precedence between '.' '@'

4.	Test if then else fi expression

5.	Test while loop

6.	Test NEW expression

7.	Test '+', '-', '*', '/', '~', ISVOID, '<', '<=','=', 'not', '(expr)', and 
NOT. Test precedence between these expressions and '<-', '.', '@'

8.	Test ID, integer, string, true, false. Test block expressions

We test all expressions. There is no ambiguity in our rules. We test precedence
of these operators. So tests on good input are adequate. 


In bad.cl, we test recover from bad class definition, bad feature, bad let 
binding, and bad expression in block expressions. Besides, we also test that 
parser could catch errors in the cases listed below:

1.	comparator could is not associative

2.	Error in assignment expression

3.	Error in dispatch expression

4.	Error in expressions with arithmetic/bool operators

5.	Error in case expressions, all kinds of errors in case expressions, like 
missing keywords, or wrong expressions etc

6.	Error in while expressions, all kinds of errors like wrong/missing 
keywords, wrong expressions in side while loop

7.	Error in if then else fi expressions, like wrong/missing keywords, wrong 
expressions

8.	Other expressions like new, is void, parenthesis mismatch

By now we tests the most important errors, and our parser could catch them all,
compared with reference parsers. In addition, our parser handles error and 
recover from the cases listed above. So the bad.cl test cases are adequate.

